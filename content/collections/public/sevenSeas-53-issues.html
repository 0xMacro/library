<item>
    <field name="topic">Sanitization</field>
    <field name="impact">medium</field>
    <field name="chance">low</field>
    <field name="status">fixed</field>
    <field name="commit">cf2bf324b9ad2b7b58a756ae8c2307d57c0346f1</field>
    <field name="content">
      ## [M-1] Missing sanitization checks allow bridging any NFT
  
      [TacCrossChainLayerDecoderAndSanitizer](https://github.com/Veda-Labs/boring-vault/blob/9e36ad4138b06dcace8f1a6bb795eb9a9ae10d69/src/base/DecodersAndSanitizers/Protocols/TacCrossChainLayerDecoderAndSanitizer.sol) is a decoder for the Cross Chain layer bridging contract on the TAC network. The current intended use case is to transfer USDT to and from TAC to ETH mainnet. There is no current intention to bridge NFTs, however [sendMessage()](https://github.com/Veda-Labs/boring-vault/blob/9e36ad4138b06dcace8f1a6bb795eb9a9ae10d69/src/base/DecodersAndSanitizers/Protocols/TacCrossChainLayerDecoderAndSanitizer.sol#L11-L38) allows for NFTs to be bridged as defined by the encoded [NFTAmount](https://github.com/Veda-Labs/boring-vault/blob/9e36ad4138b06dcace8f1a6bb795eb9a9ae10d69/src/interfaces/DecoderCustomTypes.sol#L694-L698) parameter. This value is not sanitized, allowing any value to be used in the NFTAmount array, resulting in allowing strategists to bridge any supported NFT without merkle tree authorization.
  
      **Remediations to Consider**
  
      Add a check that reverts if the NFTAmount array length is nonzero.

    </field>
  </item>
  
  <item>
    <field name="topic">Sanitation</field>
    <field name="impact">low</field>
    <field name="chance">low</field>
    <field name="status">fixed</field>
    <field name="commit">b6a7108104684ca12ac8184838083e7e77f826b7</field>
    <field name="content">
      ## [M-2] Incomplete decoding of `tvmTarget` address
  
      In [sendMessage()](https://github.com/Veda-Labs/boring-vault/blob/9e36ad4138b06dcace8f1a6bb795eb9a9ae10d69/src/base/DecodersAndSanitizers/Protocols/TacCrossChainLayerDecoderAndSanitizer.sol#L11-L38), the `tvmTarget` is decoded from a string of arbitrary size into 2 separate addresses to cover the larger sized addresses used on the TON network:
  
      ```solidity
         //convert ton address to bytes 
            bytes memory tvmBytes = bytes(messageV1.tvmTarget);
        
            //sanity check
            if (tvmBytes.length < 20) revert TacCrossChainLayerDecoderAndSanitizer__TvmBytesLengthTooShort(); 
      
            address tvmTarget0;
            assembly {
                tvmTarget0 := mload(add(tvmBytes, 32)) 
            }
        
            // Extract second address (bytes 20-39) if available
            address tvmTarget1;
            if (tvmBytes.length >= 40) {
                assembly {
                    tvmTarget1 := mload(add(tvmBytes, 52)) // skip length prefix + 20 bytes
                }
            }
      ```
      Reference: [TacCrossChainLayerDecoderAndSanitizer.sol#L18-35](https://github.com/Veda-Labs/boring-vault/blob/9e36ad4138b06dcace8f1a6bb795eb9a9ae10d69/src/base/DecodersAndSanitizers/Protocols/TacCrossChainLayerDecoderAndSanitizer.sol#L18-L35)
  
      However TON addresses are 48 bytes, larger than the 40 bytes covered by decoding 2 addresses, and the first address decoding at location 32 cuts of the first 12 bytes when it gets cast from bytes32 to an address, resulting in an incomplete decoding of the target address, allowing bridging to an unintended address that matches the last 36 bytes.
  
      **Remediations to Consider**
  
      Use 3 addresses, loading from memory location increments of 20, 40, and 60.
  
    </field>
  </item>
  
  <item>
    <field name="topic">Input Validation</field>
    <field name="impact">medium</field>
    <field name="chance">low</field>
    <field name="status">fixed</field>
    <field name="commit">cc0d62f9ab6be114891553ef602f47cb0d14b93f</field>
    <field name="content">
      ## [L-1] Constrain message version
  
      The [Cross chain layer contract](https://explorer.tac.build/address/0xDd57514b2Bee6b4575651cB58c68B390815589e9?tab=contract) currently only allows for one version of message, however it is upgradeable and setup to be upgraded to include additional message types which is specified by the `messageVersion` parameter. The decoder assumes the message is version 1, and decodes it as if it is, however if there are additional message versions added in the future, a differing version number could be called and the decoder would decode the message improperly, likely resulting in an error but could allow for unexpected and unverified actions to be made if verification passes.
  
      **Remediations to Consider**
  
      Constrain the version number to be equal to 1.
    </field>
  </item>
  