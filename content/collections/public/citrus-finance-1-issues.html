<item>
  <field name="topic">Protocol Design</field>
  <field name="impact">high</field>
  <field name="impactNote">Lost funds</field>
  <field name="chance">low</field>
  <field name="chanceNote">Requires admin user error</field>
  <field name="status">fixed</field>
  <field name="commit">de0ef6a6e05a817db3d91ca38f029079f438fa4c</field>
  <field name="content">
    ## [M-1] Native assets can get stuck in the module contract

    The `execTransaction()` payable function allows to send a specific value to the safe call through the `value` input parameter:

    ```solidity
    function execTransaction(
        ISafe safe,
        address to,
        uint256 value,
        bytes calldata data,
        uint8 operation,
        bytes memory signatures
    ) external payable virtual returns (bool) {
        ...

        // If execution fails, the whole transaction should fail
        // so that the nonce is not updated.
        // @dev If that transaction cannot be executed, use skipNonce.
        if (!safe.execTransactionFromModule(to, value, data, operation)) {
            revert ExecutionFailed(address(safe));
        }

        return true;
    }
    ```

    **Reference:** GlobalModule.sol#L44-80

    However, this value is being sent to the GlobalModule contract itself, and not the Safe contract. If one were to accidentally send ETH with a `execTransaction` call, then that ETH would get stuck in the contract.

    Consider removing the `payable` modifier to disallow calls with native value.
  </field>
</item>

<item>
  <field name="topic">Replay Attacks</field>
  <field name="impact">high</field>
  <field name="impactNote">Old configurations could create vulnerabilities in other parts of the system.</field>
  <field name="chance">low</field>
  <field name="chanceNote">A copy of an existing Safe must be deployed to a new chain, likelihood increasing as more txs are run over time. However, also requires vulnerable contracts or assets in other parts of the Citrus system.</field>
  <field name="status">wontdo</field>
  <field name="content">
    ## [M-2] Partial Nonce Replay Attack

    GlobalModule allows Safe’s owners to make cross-chain Safe calls by keeping track of each chain's call via that chain's GlobalModule instance's `nonces` mapping. In other words, once a call has been made on a chain, that nonce will increment, disallowing that same call from being made again (on that specific chain).

    However, if one were to deploy a **new** Safe + GlobalModule, then its `nonce` starts at zero, exposing a potential replay attack.

    For example:

    - Assume a party owns a single Safe deployed on multiple chains.
    - Assume `10` GlobalModule transactions have executed for these Safes.
    - Later, the Safe deploys a new copy to a new chain `Y`.
    - `Y` now has a new Safe (with the same owners, to get the same address), and a new GlobalModule with nonce zero.
    - The party attempts to execute or skip the 10 transactions:
        - If transaction `n` fails, then calling `skipNonce` is required. This will take time for signers to coordinate, opening a potential replay attack window where an attacker can replay up to `k` transactions (where `k < n`), in order, to manipulate onchain state. Since these transactions are potentially quite old, they could potentially expose a vulnerability in the Citrus system.
        - If all succeed, there is only a low chance of anything happening, although an attacker could still in theory frontrun with the replay attack described above.

    Consider one of the following options, depending on project needs:

    1. Expire, or optionally expire, transactions after a certain amount of time.
    2. Expose a `setNonce` that allows setting a Safe’s nonce to an arbitrary but strictly increasing value.
    3. Allow GlobalModule to be deployed with a global starting nonce value, invalidating all nonces below that constructor parameter.
  </field>
  <field name="response">
    We will warn users if their chain is not on the latest nonce and encourage them to sync it themselves. Additionally, we will ensure one of the following:
    - The product operates independently of the transaction (current project).
    - The product requires the transaction, preventing deposits until resolved (future projects).
    - A circuit breaker is in place (future projects) to:
      - Respond immediately in emergencies.
      - Allow signers to coordinate fixes.
      - Avoid blocking users from withdrawing funds where possible.
  </field>
</item>

<item>
  <field name="topic">Standards Interop</field>
  <field name="impact">high</field>
  <field name="status">fixed</field>
  <field name="commit">b847a0b073a495c2fa02a08c95d605f91e81cb5e</field>
  <field name="content">
    ## [Q-1] Incorrect EIP-712 hash

    The current `SAFE_TX_TYPEHASH` value was generated by keccak hashing the string `SafeTx(address safe, address to,uint256 value,bytes data,uint8 operation,uint256 nonce)`.

    However, the `encodeTransactionData()` implementation uses `bytes32 data` instead of `bytes data`.

    Although signing still works (as evidenced by the passing tests), this could still break offchain tooling and wallets that rely on the hash to be correct, so we recommend fixing this discrepancy.
  </field>
</item>
